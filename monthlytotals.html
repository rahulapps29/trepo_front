<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monthly Closing balance</title>
    <link rel="stylesheet" href="style.css" />
    <style>
      table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 20px;
      }
      th,
      td {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
      }
      th {
        background-color: #f2f2f2;
      }
    </style>
  </head>
  <body>
    <nav>
      <ul>
        <li><a href="index.html">Closing balance</a></li>
        <li><a href="transactiondetails.html">Transaction Details</a></li>
        <!-- <li><a href="monthlytotals.html">Monthly Totals</a></li> -->
        <li><a href="chartsheet.html">Chart</a></li>
      </ul>
    </nav>
    <h2 id="grandtotal">Closing Balance:</h2>
    <h2>Monthly Closing balance</h2>
    <div id="table-container"></div>

    <script>
      // Example JSON data from an API endpoint
      const apiUrl = "https://treporting.onrender.com/api/tasks/d";

      // Fetch data from the API
      fetch(apiUrl)
        .then((response) => response.json())
        .then((data) => {
          let totalAmt = 0;
          data.tasks.forEach((card) => {
            totalAmt += card.amt;
          });
          // console.log(totalAmt);

          //   function grandtotal() {
          //     document.getElementById(
          //       "grandtotal"
          //     ).innerHTML = `Filter total: ${totalAmt}`;
          //   }
          //   grandtotal();

          // creating initial summary
          let summary_month_year = [];
          data.tasks.forEach((entry) => {
            summary_month_year.push({
              my:
                entry.tdate.substring(0, 4) + "-" + entry.tdate.substring(5, 7),
              desc: entry.desc,
              amt: entry.amt,
              transtype: entry.transtype,
            });
          });

          function filterTransactionsByType(transactions, type) {
            return transactions.filter(
              (transaction) => transaction.transtype === type
            );
          }

          // unique month year

          let uniquemonthyear = [];
          uniquemonthyear = summary_month_year.reduce((uniqueValues, obj) => {
            if (!uniqueValues.includes(obj["my"])) {
              uniqueValues.push(obj["my"]);
            }
            return uniqueValues;
          }, []);

          let uniquemonthyear_dummy = uniquemonthyear.map((x) => {
            return { my: x, amt: 0 };
          });

          // sorting unique month year

          const sortuniquemonthyear = uniquemonthyear.sort();

          // gave to rovin

          const gave_to_rovin = filterTransactionsByType(
            summary_month_year,
            "gave to rovin"
          );

          let gave_to_rovin_summary_temp = gave_to_rovin.reduce(
            (a, { my, amt }) => {
              a[my] = a[my] || { my, amt: 0 };
              a[my].amt += amt;
              return a;
            },
            {}
          );

          let gave_to_rovin_summary_temp2 = [
            ...Object.values(uniquemonthyear_dummy),
            ...Object.values(gave_to_rovin_summary_temp),
          ];

          let gave_to_rovin_summary = gave_to_rovin_summary_temp2.reduce(
            (a, { my, amt }) => {
              a[my] = a[my] || { my, amt: 0 };
              a[my].amt += amt;
              return a;
            },
            {}
          );

          // got from rovin

          const got_from_rovin = filterTransactionsByType(
            summary_month_year,
            "got from rovin"
          );

          let got_from_rovin_summary_temp = got_from_rovin.reduce(
            (a, { my, amt }) => {
              a[my] = a[my] || { my, amt: 0 };
              a[my].amt += amt;
              return a;
            },
            {}
          );

          let got_from_rovin_summary_temp2 = [
            ...Object.values(uniquemonthyear_dummy),
            ...Object.values(got_from_rovin_summary_temp),
          ];

          let got_from_rovin_summary = got_from_rovin_summary_temp2.reduce(
            (a, { my, amt }) => {
              a[my] = a[my] || { my, amt: 0 };
              a[my].amt += amt;
              return a;
            },
            {}
          );

          // combine summary

          const rovin_summary = [
            ...Object.values(got_from_rovin_summary),
            ...Object.values(gave_to_rovin_summary),
          ];

          const got_from_rovin_summary_sorted = Object.values(
            got_from_rovin_summary
          ).sort(dynamicSort("my"));
          const gave_to_rovin_summary_sorted = Object.values(
            gave_to_rovin_summary
          ).sort(dynamicSort("my"));

          // console.log(filteredTransactions);

          // monthly summary

          let monthlysummary = summary_month_year.reduce((a, { my, amt }) => {
            a[my] = a[my] || { my, amt: 0 };
            a[my].amt += amt;
            return a;
          }, {});

          const monthlysummary_sorted = Object.values(monthlysummary).sort(
            dynamicSort("my")
          );
          let runningTotal = 0;
          Object.values(monthlysummary_sorted).forEach((item) => {
            runningTotal += item.amt;
            item.running_total = runningTotal;
          });

          let closingbalance = [];
          monthlysummary_sorted.forEach((num1, index) => {
            const num2 = gave_to_rovin_summary_sorted[index];
            const num3 = got_from_rovin_summary_sorted[index];
            closingbalance.push({
              year_month: num1.my,

              gave_to_rovin: num2.amt,
              got_from_rovin: num3.amt,
              ClosingBalance: num1.running_total,
            });
          });

          // unique card list

          let uniquecards = [];
          uniquecards = summary_month_year.reduce((uniqueValues, obj) => {
            if (!uniqueValues.includes(obj["desc"])) {
              uniqueValues.push(obj["desc"]);
            }
            return uniqueValues;
          }, []);

          const colorNumberlist = Array.from(
            { length: uniquecards.length },
            (_, i) => i + 1
          );

          colorlist = colorNumberlist.map((x) => {
            return [selectColor(x, uniquecards.length)];
          });

          const crossProduct = (a, b) =>
            a.reduce((acc, x) => [...acc, ...b.map((y) => [x, y])], []);

          const crossp = crossProduct(uniquemonthyear, uniquecards);

          crosspd = crossp.map((x) => {
            return { my: x[0], desc: x[1], amt: 0 };
          });

          const summary_step1 = [...summary_month_year, ...crosspd];

          let crosspe = summary_step1.map((x) => {
            return { my: x.my + " " + x.desc, amt: x.amt };
          });

          let summary_step2 = crosspe.reduce((a, { my, amt }) => {
            a[my] = a[my] || { my, amt: 0 };
            a[my].amt += amt;
            return a;
          }, {});
          let summary_step3 = Object.values(summary_step2);

          let crosspf = summary_step3.map((x) => {
            return {
              my: x.my.substring(0, 7),
              desc: x.my.substring(8, x.my.length),
              amt: x.amt,
            };
          });

          const sort1 = crosspf.sort(dynamicSort("desc"));
          const sort2 = sort1.sort(dynamicSort("my"));
          const sort3 = sort2.sort(dynamicSort("desc"));
          const sort_populate = summary_month_year.sort(dynamicSort("desc"));
          const sort_populate2 = sort_populate.sort(dynamicSort("my"));
          console.log(sort_populate2);
          function dynamicSort(property) {
            var sortOrder = 1;
            if (property[0] === "-") {
              sortOrder = -1;
              property = property.substr(1);
            }
            return function (a, b) {
              /* next line works with strings and numbers,
               * and you may want to customize it to your needs
               */
              var result =
                a[property] < b[property]
                  ? -1
                  : a[property] > b[property]
                  ? 1
                  : 0;
              return result * sortOrder;
            };
          }
          function selectColor(colorNum, colors) {
            if (colors < 1) colors = 1; // defaults to one color - avoid divide by zero
            return "hsl(" + ((colorNum * (360 / colors)) % 360) + ",100%,50%)";
          }
        })

        .catch((error) => console.error("Error fetching data:", error));
    </script>
  </body>
</html>
